/**
 * Cloudway Platform
 * Copyright (c) 2012-2013 Cloudway Technology, Inc.
 * All rights reserved.
 */

package com.cloudway.platform.common.fp.control;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.cloudway.platform.common.fp.data.Fn;
import com.cloudway.platform.common.fp.data.Seq;
import com.cloudway.platform.common.fp.data.Unit;

/**
 * A {@code Generator} is a special routine that can be used to control the
 * iteration behaviour of a loop. In fact, all {@code Generator}s are
 * {@code Iterator}s. A generator is very similar to a function that returns
 * an array, in that a generator has parameters, can be called, and generates
 * a sequence of values. However, instead of building an array containing all
 * the values and returning them all at once, a generator yields the values
 * one at a time, which requires less memory and allows the caller to get started
 * processing the first few values immediately. In short, a generator looks like
 * a function but behaves like an iterator.
 *
 * @param <A> the type of yielded value
 */
public interface Generator<A> extends Iterable<A> {
    /**
     * A channel to communicate between generators.
     *
     * @param <A> the type of yielded value
     */
    interface Channel<A> extends Iterator<A> {
        /**
         * Send a value to a cooperate generator.
         *
         * @param value the value to send
         * @return a value generated by cooperate generator
         * @throws NoSuchElementException if channel is finished
         */
        A send(A value);
    }

    /**
     * Start communicate through a channel.
     *
     * @return a {@code Channel} used to communication
     */
    Channel<A> start();

    /**
     * Returns a list view of generated values, may be infinite.
     *
     * @return a list containing generated values
     */
    default Seq<A> asList() {
        return foldRight(Seq.nil(), Seq::cons);
    }

    // Monad

    /**
     * Yield a pure computation that results in the given value.
     *
     * @param a the pure value of the computation result
     * @return the generator that yield the pure value
     */
    static <A> Generator<A> pure(A a) {
        return new Generators.Pure<>(a);
    }

    /**
     * Returns a generator consisting of the elements of this generator that
     * matches the given predicate.
     *
     * @param predicate a predicate to apply to each element to determine if it
     * should be included
     * @return a filtered generator
     */
    Generator<A> filter(Predicate<? super A> predicate);

    /**
     * Returns a generator consisting of the results of applying the given
     * function to the elements of this generator.
     *
     * @param <B> the element type of the new generator
     * @param mapper a function to apply to each element
     * @return a new generator
     */
    <B> Generator<B> map(Function<? super A, ? extends B> mapper);

    /**
     * Returns a generator consisting of the results of replacing each element
     * of this generator with the contents of a mapped generator produced by
     * applying the provided mapping function to each element.
     *
     * @param <B> the element type of the new generator
     * @param mapper a function to apply to each element which produces a generator
     * of new values
     * @return the new generator
     */
    <B> Generator<B> bind(Function<? super A, ? extends Generator<B>> mapper);

    /**
     * Transfer a generator by discarding the intermediate value.
     *
     * @param b the new generator transformation
     * @return a generator that transfers this generator to the given generator
     */
    default <B> Generator<B> then(Generator<B> b) {
        return bind(Fn.pure(b));
    }

    /**
     * Transfer a generator by discarding the intermediate value.
     *
     * @param b the new generator transformation
     * @return a generator that transfers this generator to the given generator
     */
    default <B> Generator<B> then(Supplier<Generator<B>> b) {
        return bind(x -> b.get());
    }

    /**
     * Reduce the generator using the binary operator, from right to left. This is
     * a lazy operation so the accumulator accept a delay evaluation of reduced
     * result instead of a strict value.
     *
     * @param identity the identity value for the accumulating function
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    <R> R foldRight(R identity, BiFunction<? super A, Supplier<R>, R> accumulator);

    /**
     * The strict version of {@link #foldRight(Object,BiFunction) foldRight}.
     *
     * @param identity the identity value for the accumulating function
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    default <R> R foldRight_(R identity, BiFunction<? super A, R, R> accumulator) {
        return foldRight(identity, (x, r) -> accumulator.apply(x, r.get()));
    }

    /**
     * A variant of {@link #foldRight(Object,BiFunction)} that has no starting
     * value argument.
     *
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    default Optional<A> foldRight(BinaryOperator<A> accumulator) {
        BiFunction<A, Optional<A>, Optional<A>> mf =
            (x, my) -> my.isPresent() ? Optional.of(accumulator.apply(x, my.get()))
                                      : Optional.of(x);
        return foldRight_(Optional.empty(), mf);
    }

    /**
     * Reduce the generator using the binary operator, from left to right.
     *
     * @param identity the identity value for the accumulating function
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    default <R> R foldLeft(R identity, BiFunction<R, ? super A, R> accumulator) {
        R result = identity;
        for (A a : this)
            result = accumulator.apply(result, a);
        return result;
    }

    /**
     * A variant of {@link #foldLeft(Object,BiFunction)} that has no starting
     * value argument.
     *
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    default Optional<A> foldLeft(BinaryOperator<A> accumulator) {
        Iterator<A> it = iterator();
        if (it.hasNext()) {
            A result = it.next();
            while (it.hasNext())
                result = accumulator.apply(result, it.next());
            return Optional.of(result);
        } else {
            return Optional.empty();
        }
    }

    /**
     * Zip two generator into one using a function to produce result values.
     */
    <B, C> Generator<C> zip(Generator<B> b, BiFunction<? super A, ? super B, ? extends C> zipper);

    /**
     * The static version of {@link #zip(Generator, BiFunction)}.
     */
    static <A, B, C> Generator<C> zip(Generator<A> a, Generator<B> b,
              BiFunction<? super A, ? super B, ? extends C> zipper) {
        return a.zip(b, zipper);
    }

    /**
     * Evaluate each action in the sequence from left to right, and collect
     * the result.
     */
    static <A> Generator<Seq<A>> flatM(Seq<Generator<A>> ms) {
        return ms.foldRight_(pure(Seq.nil()), liftM2(Seq::cons));
    }

    /**
     * Evaluate each action in the sequence from left to right, and ignore
     * the result.
     */
    static <A> Generator<Unit> sequence(Seq<Generator<A>> ms) {
        return ms.foldRight(pure(Unit.U), Generator::then);
    }

    /**
     * The {@code mapM} is analogous to {@link Seq#map(Function) map} except that
     * its result is encapsulated in a {@code Generator}.
     */
    static <A, B> Generator<Seq<B>> mapM(Seq<A> xs, Function<? super A, Generator<B>> f) {
        return flatM(xs.map(f));
    }

    /**
     * {@code mapM_} is equivalent to {@code sequence(xs.map(f))}.
     */
    static <A, B> Generator<Unit> mapM_(Seq<A> xs, Function<? super A, Generator<B>> f) {
        return sequence(xs.map(f));
    }

    /**
     * Generalizes {@link Seq#zip(Seq,BiFunction)} to arbitrary monads.
     * Bind the given function to the given generators with a final join.
     */
    static <A, B, C> Generator<Seq<C>> zipM(Seq<A> xs, Seq<B> ys,
                BiFunction<? super A, ? super B, Generator<C>> f) {
        return flatM(Seq.zip(xs, ys, f));
    }

    /**
     * The extension of {@link #zipM(Seq,Seq,BiFunction) zipM} which ignores the
     * final result.
     */
    static <A, B, C> Generator<Unit> zipM_(Seq<A> xs, Seq<B> ys,
                BiFunction<? super A, ? super B, Generator<C>> f) {
        return sequence(Seq.zip(xs, ys, f));
    }

    /**
     * This generalizes the list-based filter function.
     */
    static <A> Generator<Seq<A>> filterM(Seq<A> xs, Function<? super A, Generator<Boolean>> p) {
        return xs.isEmpty()
               ? pure(Seq.nil())
               : p.apply(xs.head()).bind(flg ->
                 filterM(xs.tail(), p).bind(ys ->
                 pure(flg ? Seq.cons(xs.head(), ys) : ys)));
    }

    /**
     * The {@code foldM} is analogous to {@link Seq#foldLeft(Object,BiFunction) foldLeft},
     * except that its result is encapsulated in a {@code Generator}. Note that
     * {@code foldM} works from left-to-right over the lists arguments. If right-to-left
     * evaluation is required, the input list should be reversed.
     */
    static <A, B> Generator<B> foldM(B r0, Seq<A> xs, BiFunction<B, ? super A, Generator<B>> f) {
        return xs.foldLeft(pure(r0), (m, x) -> m.bind(r -> f.apply(r, x)));
    }

    /**
     * Performs the action n times, gathering the results.
     */
    static <A> Generator<Seq<A>> replicateM(int n, Generator<A> a) {
        return flatM(Seq.replicate(n, a));
    }

    /**
     * Performs the action n times, discards the result.
     */
    static <A> Generator<Unit> replicateM_(int n, Generator<A> a) {
        return sequence(Seq.replicate(n, a));
    }

    /**
     * Kleisli composition of monads.
     */
    static <A, B, C> Function<A, Generator<C>>
    kleisli(Function<A, Generator<B>> f, Function<B, Generator<C>> g) {
        return x -> f.apply(x).bind(g);
    }

    /**
     * Promote a function to a generator function.
     */
    static <A, B, C> Function<Generator<A>, Generator<B>>
    liftM(Function<? super A, ? extends B> f) {
        return m -> m.map(f);
    }

    /**
     * Promote a function to a generator function.
     */
    static <A, B, C> BiFunction<Generator<A>, Generator<B>, Generator<C>>
    liftM2(BiFunction<? super A, ? super B, ? extends C> f) {
        return (m1, m2) -> m1.bind(x1 -> m2.map(x2 -> f.apply(x1, x2)));
    }
}
