/**
 * Cloudway Platform
 * Copyright (c) 2012-2013 Cloudway Technology, Inc.
 * All rights reserved.
 */

package com.cloudway.platform.common.fp.control;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.cloudway.platform.common.fp.data.Fn;
import com.cloudway.platform.common.fp.data.Foldable;
import com.cloudway.platform.common.fp.data.Seq;
import com.cloudway.platform.common.fp.data.Traversable;
import com.cloudway.platform.common.fp.data.Unit;
import com.cloudway.platform.common.fp.$;

/**
 * A {@code Generator} is a special routine that can be used to control the
 * iteration behaviour of a loop. In fact, all {@code Generator}s are
 * {@code Iterator}s. A generator is very similar to a function that returns
 * an array, in that a generator has parameters, can be called, and generates
 * a sequence of values. However, instead of building an array containing all
 * the values and returning them all at once, a generator yields the values
 * one at a time, which requires less memory and allows the caller to get started
 * processing the first few values immediately. In short, a generator looks like
 * a function but behaves like an iterator.
 *
 * @param <A> the type of yielded value
 */
public interface Generator<A> extends $<Generator.µ, A>, Foldable<A> {
    /**
     * A channel to communicate between generators.
     *
     * @param <A> the type of yielded value
     */
    interface Channel<A> extends Iterator<A> {
        /**
         * Send a value to a cooperate generator.
         *
         * @param value the value to send
         * @return a value generated by cooperate generator
         * @throws NoSuchElementException if channel is finished
         */
        A send(A value);
    }

    /**
     * Start communicate through a channel.
     *
     * @return a {@code Channel} used to communication
     */
    Channel<A> start();

    // Monad

    /**
     * Yield a pure computation that results in the given value.
     *
     * @param a the pure value of the computation result
     * @return the generator that yield the pure value
     */
    static <A> Generator<A> pure(A a) {
        return new Generators.Pure<>(a);
    }

    /**
     * Returns a generator consisting of the elements of this generator that
     * matches the given predicate.
     *
     * @param predicate a predicate to apply to each element to determine if it
     * should be included
     * @return a filtered generator
     */
    Generator<A> filter(Predicate<? super A> predicate);

    /**
     * Returns a generator consisting of the results of applying the given
     * function to the elements of this generator.
     *
     * @param <B> the element type of the new generator
     * @param mapper a function to apply to each element
     * @return a new generator
     */
    <B> Generator<B> map(Function<? super A, ? extends B> mapper);

    /**
     * Returns a generator consisting of the results of replacing each element
     * of this generator with the contents of a mapped generator produced by
     * applying the provided mapping function to each element.
     *
     * @param <B> the element type of the new generator
     * @param mapper a function to apply to each element which produces a generator
     * of new values
     * @return the new generator
     */
    <B> Generator<B> bind(Function<? super A, ? extends $<µ, B>> mapper);

    /**
     * Transfer a generator by discarding the intermediate value.
     *
     * @param b the new generator transformation
     * @return a generator that transfers this generator to the given generator
     */
    default <B> Generator<B> then($<µ, B> b) {
        return bind(Fn.pure(b));
    }

    /**
     * Transfer a generator by discarding the intermediate value.
     *
     * @param b the new generator transformation
     * @return a generator that transfers this generator to the given generator
     */
    default <B> Generator<B> then(Supplier<? extends $<µ, B>> b) {
        return bind(x -> b.get());
    }

    /**
     * Reduce the generator using the binary operator, from left to right.
     *
     * @param identity the identity value for the accumulating function
     * @param accumulator a function for combining two values
     * @return the result of the reduction
     */
    @Override
    default <R> R foldLeft(R identity, BiFunction<R, ? super A, R> accumulator) {
        R result = identity;
        for (A a : this) {
            result = accumulator.apply(result, a);
        }
        return result;
    }

    /**
     * Performs the given action for each element of the {@code Iterable}
     * until all elements have been processed or the action throws an
     * exception.
     *
     * @param action The action to be performed for each element
     */
    @Override
    default void forEach(Consumer<? super A> action) {
        for (A a : this) {
            action.accept(a);
        }
    }

    /**
     * Zip two generator into one using a function to produce result values.
     */
    <B, C> Generator<C> zip(Generator<B> b, BiFunction<? super A, ? super B, ? extends C> zipper);

    /**
     * The static version of {@link #zip(Generator, BiFunction)}.
     */
    static <A, B, C> Generator<C> zip(Generator<A> a, Generator<B> b,
              BiFunction<? super A, ? super B, ? extends C> zipper) {
        return a.zip(b, zipper);
    }

    // Monad

    interface µ extends Monad<µ> {
        @Override
        default <A> Generator<A> pure(A a) {
            return Generator.pure(a);
        }

        @Override
        default <A, B> Generator<B> map($<µ, A> a, Function<? super A, ? extends B> f) {
            return narrow(a).map(f);
        }

        @Override
        default <A, B> Generator<B> bind($<µ, A> a, Function<? super A, ? extends $<µ, B>> k) {
            return narrow(a).bind(k);
        }

        @Override
        default <A, B> Generator<B> seqR($<µ, A> a, $<µ, B> b) {
            return narrow(a).then(b);
        }

        @Override
        default <A, B> Generator<B> seqR($<µ, A> a, Supplier<? extends $<µ, B>> b) {
            return narrow(a).then(b);
        }
    }

    static <A> Generator<A> narrow($<µ, A> value) {
        return (Generator<A>)value;
    }

    µ tclass = new µ() {};

    @Override
    default µ getTypeClass() {
        return tclass;
    }

    // Convenient static monad methods

    static <T, A> Generator<? extends Traversable<T, A>>
    flatM(Traversable<T, ? extends $<µ, A>> ms) {
        return narrow(tclass.flatM(ms));
    }

    @SuppressWarnings("unchecked")
    static <A> Generator<Seq<A>> flatM(Seq<? extends $<µ, A>> ms) {
        return (Generator<Seq<A>>)tclass.flatM(ms);
    }

    static <T, A, B> Generator<? extends Traversable<T, B>>
    mapM(Traversable<T, A> xs, Function<? super A, ? extends $<µ, B>> f) {
        return narrow(tclass.mapM(xs, f));
    }

    @SuppressWarnings("unchecked")
    static <A, B> Generator<Seq<B>>
    mapM(Seq<A> xs, Function<? super A, ? extends $<µ, B>> f) {
        return (Generator<Seq<B>>)tclass.mapM(xs, f);
    }

    static <A> Generator<Unit> sequence(Foldable<? extends $<µ, A>> ms) {
        return narrow(tclass.sequence(ms));
    }

    static <A, B> Generator<Unit>
    mapM_(Foldable<A> xs, Function<? super A, ? extends $<µ, B>> f) {
        return narrow(tclass.mapM_(xs, f));
    }

    static <A> Generator<Seq<A>>
    filterM(Seq<A> xs, Function<? super A, ? extends $<µ, Boolean>> p) {
        return narrow(tclass.filterM(xs, p));
    }

    static <A, B> Generator<B>
    foldM(B r0, Foldable<A> xs, BiFunction<B, ? super A, ? extends $<µ, B>> f) {
        return narrow(tclass.foldM(r0, xs, f));
    }

    static <A> Generator<Seq<A>> replicateM(int n, $<µ, A> a) {
        return narrow(tclass.replicateM(n, a));
    }

    static <A> Generator<Unit> replicateM_(int n, $<µ, A> a) {
        return narrow(tclass.replicateM_(n, a));
    }
}
