/**
 * Cloudway Platform
 * Copyright (c) 2012-2013 Cloudway Technology, Inc.
 * All rights reserved.
 */

package com.cloudway.platform.common.fp.data;

import java.util.Collection;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.OptionalInt;
import java.util.RandomAccess;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.UnaryOperator;

import com.cloudway.platform.common.fp.control.Trampoline;
import com.cloudway.platform.common.fp.function.TriFunction;

/**
 * Provides an immutable finite vector, implemented as a finger tree. This
 * structure gives O(1) access to the head and tail, as well as O(log n)
 * random access and concatenation of sequences.
 *
 * @param <A> The element type of the vector
 */
public interface Vector<A> extends Foldable<A> {
    /**
     * Construct an empty vector.
     *
     * @return a vector with no elements.
     */
    static <A> Vector<A> empty() {
        return VectorImpl.emptyTree();
    }

    /**
     * Construct a vector with a single element.
     *
     * @param value the single element in the vector
     * @return a new vector with the given element in it
     */
    static <A> Vector<A> singleton(A value) {
        return VectorImpl.singleTree(value);
    }

    /**
     * Construct a vector with a given length and a function representing vector
     * elements, producing vector consisting of {@code f(0), f(1), ..., f(n)}.
     *
     * @param len number of elements to produce
     * @param f a function produce vector element
     * @return a vector with given length and applying function as elements
     */
    static <A> Vector<A> iterate(int len, IntFunction<A> f) {
        return VectorImpl.iterate(len, f);
    }

    /**
     * Construct a vector with given elements.
     *
     * @param values an array of elements
     * @return a new vector with the given elements in it
     */
    @SafeVarargs
    static <A> Vector<A> of(A... values) {
        return iterate(values.length, i -> values[i]);
    }

    /**
     * Construct a vector from a collection.
     *
     * @param xs a collection of elements
     * @return a vector with elements from the given collection
     */
    static <A> Vector<A> fromCollection(Collection<A> xs) {
        if (xs instanceof java.util.List && xs instanceof RandomAccess) {
            java.util.List<A> l = (java.util.List<A>)xs;
            return iterate(l.size(), l::get);
        } else {
            Vector<A> v = empty();
            for (A x : xs)
                v = v.snoc(x);
            return v;
        }
    }

    /**
     * Construct a vector from a list.
     *
     * @param xs a list consisting elements to be put into vector
     * @return a new vector with elements from the given list
     */
    static <A> Vector<A> fromList(Seq<A> xs) {
        Ref<Seq<A>> ref = new Ref<>(xs);
        return iterate((int)xs.count(), i -> ref.getAndUpdate(Seq::tail).head());
    }

    /**
     * Construct a vector produced by iterative application of a function
     * ({@code f}) to an initial element ({@code a0}), producing vector
     * consisting of {@code a0, f(seed), f(f(a0)), ...}, etc.
     *
     * @param len number of elements to produce
     * @param seed the initial element
     * @param f a function produce vector element
     * @return a vector produced by iterative application of a function to
     * an initial element
     */
    static <A> Vector<A> iterate(int len, A seed, UnaryOperator<A> f) {
        Ref<A> ref = new Ref<>(seed);
        return iterate(len, i -> ref.getAndUpdate(f));
    }

    /**
     * Returns a vector where element is generated by the provided
     * {@code Supplier}. This is suitable for generating constant sequences,
     * sequences of random elements, etc.
     *
     * @param len number of elements to generate
     * @param s the {@code Supplier} to generate element value
     */
    static <A> Vector<A> generate(int len, Supplier<A> s) {
        return iterate(len, i -> s.get());
    }

    /**
     * Create a vector of length {@code n} with the value of every element.
     *
     * @param n number of elements to replicate
     * @param value the value to replicate
     * @return a vector of length {@code n} with the value of every element
     */
    static <A> Vector<A> replicate(int n, A value) {
        return iterate(n, i -> value);
    }

    /**
     * Returns the vector monoid.
     *
     * @return the vector monoid
     */
    static <A> Monoid<Vector<A>> monoid() {
        return Monoid.monoid_(empty(), Vector::append);
    }

    /**
     * Returns true if the vector contains no elements.
     *
     * @return true if the vector contains no elements
     */
    boolean isEmpty();

    /**
     * Returns the number of elements in this vector.
     *
     * @return the number of elements in this vector
     */
    int size();

    /**
     * Returns the first element in the vector, which must be non-empty.
     *
     * @return the first element in the vector
     * @throws NoSuchElementException if the vector is empty
     */
    A head();

    /**
     * Returns the last element in the vector, which must be non-empty.
     *
     * @return the last element in the vector
     * @throws NoSuchElementException if the vector is empty
     */
    A last();

    /**
     * Returns a vector consisting elements after the head of this vector,
     * which must be non-empty.
     *
     * @return a vector consisting elements after the head of this vector
     * @throws NoSuchElementException if the vector is empty
     */
    Vector<A> tail();

    /**
     * Returns a vector consisting elements of this vector except the last
     * one. The vector must be non-empty.
     *
     * @return a vector consisting elements of this vector except the last one
     * @throws NoSuchElementException if the vector is empty
     */
    Vector<A> init();

    /**
     * Inserts the given element at the from of this vector.
     *
     * @param a an element to insert at the front of this vector
     * @return a new vector with the given element at the front
     */
    Vector<A> cons(A a);

    /**
     * Inserts the given element at the end of this vector.
     *
     * @param a an element to insert at the end of this vector
     * @return a new vector with the given element at the end
     */
    Vector<A> snoc(A a);

    /**
     * Appends the given vector to this vector.
     *
     * @param that a vector to append to this one
     * @return a new vector with the given vector appended to this one
     */
    Vector<A> append(Vector<A> that);

    /**
     * Returns the element at the specified position in this vector.
     *
     * @param index index of the element to return
     * @return the element at the specified position in this list
     * @throws IndexOutOfBoundsException if the index is out or range
     */
    A at(int index);

    /**
     * Replaces the element at the specified position in this vector with the
     * specified value.
     *
     * @param index index of the element to replace
     * @param value element to be stored at the specified position
     * @return a new vector with the given element replaced at the specified position
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    Vector<A> update(int index, A value);

    /**
     * Replaces the element at the specified position in the vector with
     * applying the given function.
     *
     * @param index index of the element to replace
     * @param f a function that compute from old value to new value
     * @return a new vector with the given element replaced at the specified position
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    Vector<A> modify(int index, UnaryOperator<A> f);

    /**
     * Deletes the element at the specified position in this vector.
     *
     * @param index the index of the element to be deleted
     * @return a new vector with the given element deleted at the specified position
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    Vector<A> delete(int index);

    /**
     * Inserts the specified element at the specified position in this vector.
     *
     * @param index index at which the specified element is to be inserted
     * @param value element to be inserted
     * @return a new vector with the given element inserted at the specified position
     * @throws IndexOutOfBoundsException if the index is out of range
     */
    Vector<A> insert(int index, A value);

    /**
     * Split the vector at the given position.
     *
     * @param index index of the position to split
     * @return a tuple contains vectors splits at given position
     */
    Pair<Vector<A>> splitAt(int index);

    /**
     * Returns a vector with given limited elements taken.
     *
     * @param n number of elements to take
     * @return a vector with given limited elements taken
     */
    default Vector<A> take(int n) {
        return splitAt(n).first();
    }

    /**
     * Returns a vector with given number of elements dropped.
     *
     * @param n number of elements to drop
     * @return a vector with given number of elements dropped
     */
    default Vector<A> drop(int n) {
        return splitAt(n).second();
    }

    /**
     * Returns a portion of this vector between the specified {@code fromIndex},
     * inclusive, and {@code toIndex}, exclusive.  (If {@code fromIndex} and
     * {@code toIndex} are equal, the returned sequence is empty.)
     *
     * @param fromIndex low endpoint (inclusive) of the sub sequence
     * @param toIndex high endpoint (exclusive) of the sub sequence
     * @return a sub sequence of the specified range with this vector
     * @throws IndexOutOfBoundsException for an illegal endpoint index value
     *         (<tt>fromIndex &lt; 0 || toIndex &gt; size ||
     *         fromIndex &gt; toIndex</tt>)
     */
    default Vector<A> subSequence(int fromIndex, int toIndex) {
        if (fromIndex < 0)
            throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
        if (toIndex > size())
            throw new IndexOutOfBoundsException("toIndex = " + toIndex);
        if (fromIndex > toIndex)
            throw new IllegalArgumentException("fromIndex(" + fromIndex +
                                               ") > toIndex(" + toIndex + ")");
        return drop(fromIndex).take(toIndex - fromIndex);
    }

    /**
     * Returns a vector consisting of the results of applying the given function
     * to the elements of this vector.
     *
     * @param <B> the element type of the new vector
     * @param f a function to apply to each element
     * @return a vector consisting of the results of applying the given function
     * to the elements of this vector
     */
    <B> Vector<B> map(Function<? super A, ? extends B> f);

    /**
     * Returns a vector consisting of the elements of this vector that match the
     * given predicate.
     *
     * @param p a predicate to apply to each element to determine if it
     * should be included
     * @return the vector consisting of the elements of this vector that match the
     * given predicate
     */
    default Vector<A> filter(Predicate<? super A> p) {
        return foldLeft(empty(), (xs, x) -> p.test(x) ? xs.snoc(x) : xs);
    }

    /**
     * Reverse elements in this vector.
     *
     * @return a reversed vector
     */
    Vector<A> reverse();

    /**
     * Zip two vectors into a vector of tuples.
     *
     * @param that another vector to zip with this vector
     * @return a vector has two vectors zipped with tuples
     */
    default <B> Vector<Tuple<A,B>> zip(Vector<B> that) {
        return zipWith(that, Tuple::of);
    }

    /**
     * Zip two vector into one using a function to produce result values.
     *
     * @param that another vector to zip with this vector
     * @param f a function to produce zipped value
     * @return a vector has two vectors zipped with given function
     */
    <B, C> Vector<C> zipWith(Vector<B> that, BiFunction<? super A, ? super B, ? extends C> f);

    /**
     * Zip three vectors into a vector of triples.
     *
     * @param bs another vector to zip with this vector
     * @param cs another vector to zip with this vector
     * @return a vector has three vectors zipped with triples
     */
    default <B, C> Vector<Triple<A,B,C>> zip(Vector<B> bs, Vector<C> cs) {
        return zipWith(bs, cs, Tuple::of);
    }

    /**
     * Zip three vectors into one using a function to produce result values.
     *
     * @param bs another vector to zip with this vector
     * @param cs another vector to zip with this vector
     * @param f a function to produce zipped value
     * @return a vector has three vectors zipped with given function
     */
    default <B,C,D> Vector<D> zipWith(Vector<B> bs, Vector<C> cs,
            TriFunction<? super A, ? super B, ? super C, ? extends D> f) {
        int minLen = Math.min(Math.min(this.size(), bs.size()), cs.size());
        Vector<A> s1 = this.take(minLen);
        Vector<B> s2 = bs.take(minLen);
        Vector<C> s3 = cs.take(minLen);
        BiFunction<A, B, Function<C, D>> zf = (a, b) -> c -> f.apply(a, b, c);
        return s1.zipWith(s2, zf).zipWith(s3, Function::apply);
    }

    // Folding Extensions

    /**
     * Like {@link Foldable#foldRight(BiFunction,Supplier) foldRight} but with
     * element index as an argument to the accumulator function.
     *
     * @param <R> the type of the result
     * @param f an associative non-interfering function for combining two values
     * @param r the partial reduction result to the accumulator
     * @return the result of the reduction
     */
    default <R> R foldRightWithIndex(TriFunction<Integer, ? super A, Supplier<R>, R> f, Supplier<R> r) {
        BiFunction<? super A, Supplier<IntFunction<R>>, IntFunction<R>>
            mf = (x, g) -> i -> f.apply(i, x, () -> g.get().apply(i + 1));
        return foldRight(mf, () -> i -> r.get()).apply(0);
    }

    /**
     * Like {@link Foldable#foldRight_(Object,BiFunction) foldRight_} but with
     * element index as an argument to the accumulator function.
     *
     * @param <R> the type of the result
     * @param z the identity of the result
     * @param f an associative non-interfering function for combining two values
     * @return the result of the reduction
     */
    default <R> R foldRightWithIndex_(R z, TriFunction<Integer, ? super A, R, R> f) {
        TriFunction<Integer, ? super A, Supplier<Trampoline<R>>, Trampoline<R>>
            mf = (i, x, t) -> Trampoline.suspend(() -> t.get().map(r -> f.apply(i, x, r)));
        return foldRightWithIndex(mf, () -> Trampoline.pure(z)).run();
    }

    /**
     * Like {@link Foldable#foldLeft(BiFunction,Supplier) foldLeft} but with
     * element index as an argument to the accumulator function.
     *
     * @param <R> the type of the result
     * @param f an associative non-interfering function for combining two values
     * @param r the partial reduction result to the accumulator
     * @return the result of the reduction
     */
    default <R> R foldLeftWithIndex(TriFunction<Supplier<R>, Integer, ? super A, R> f, Supplier<R> r) {
        BiFunction<Supplier<IntFunction<R>>, ? super A, IntFunction<R>>
            mf = (g, x) -> i -> f.apply(() -> g.get().apply(i - 1), i, x);
        return foldLeft(mf, () -> i -> r.get()).apply(size() - 1);
    }

    /**
     * Like {@link Foldable#foldLeft(Object,BiFunction) foldLeft} but with
     * element index as an argument to the accumulator function.
     *
     * @param <R> the type of the result
     * @param z the identity of the result
     * @param f an associative non-interfering function for combining two values
     * @return the result of the reduction
     */
    default <R> R foldLeftWithIndex_(R z, TriFunction<R, Integer, ? super A, R> f) {
        TriFunction<Supplier<Trampoline<R>>, Integer, ? super A, Trampoline<R>>
            mf = (t, i, x) -> Trampoline.suspend(() -> t.get().map(r -> f.apply(r, i, x)));
        return foldLeftWithIndex(mf, () -> Trampoline.pure(z)).run();
    }

    /**
     * Finds the index of the leftmost element that satisfies the given predicate,
     * if any exist.
     *
     * @param p the predicate to test on element
     * @return the index of the leftmost element that satisfies the given predicate,
     * or empty if no such element found
     */
    default OptionalInt findIndexL(Predicate<? super A> p) {
        TriFunction<Integer, ? super A, Supplier<Trampoline<OptionalInt>>, Trampoline<OptionalInt>>
            g = (i, x, r) -> p.test(x) ? Trampoline.pure(OptionalInt.of(i))
                                       : Trampoline.suspend(r);
        return foldRightWithIndex(g, () -> Trampoline.pure(OptionalInt.empty())).run();
    }

    /**
     * Finds the index of the rightmost element that satisfies the given predicate,
     * if any exist.
     *
     * @param p the predicate to test on element
     * @return the index of the rightmost element that satisfies the given predicate,
     * or empty if no such element found
     */
    default OptionalInt findIndexR(Predicate<? super A> p) {
        TriFunction<Supplier<Trampoline<OptionalInt>>, Integer, ? super A, Trampoline<OptionalInt>>
            g = (r, i, x) -> p.test(x) ? Trampoline.pure(OptionalInt.of(i))
                                       : Trampoline.suspend(r);
        return foldLeftWithIndex(g, () -> Trampoline.pure(OptionalInt.empty())).run();
    }

    /**
     * Returns the index of the first occurrence of the specified element in
     * this vector, or -1 if this vector does not contain the element.
     *
     * @param o element to search for
     * @return the index of the first occurrence of the specified element in
     * this vector, or -1 if this vector does not contain the element
     */
    default int indexOf(Object o) {
        return findIndexL(a -> Objects.equals(a, o)).orElse(-1);
    }

    /**
     * Returns the index of the last occurrence of the specified element in
     * this vector, or -1 if this vector does not contain the element.
     *
     * @param o element to search for
     * @return the index of the last occurrence of the specified element in
     * this vector, or -1 if this vector does not contain the element
     */
    default int lastIndexOf(Object o) {
        return findIndexR(a -> Objects.equals(a, o)).orElse(-1);
    }

    /**
     * Returns <tt>true</tt> if this vector contains the specified element.
     *
     * @param o element whose presence in this list is to be tested
     * @return <tt>true</tt> if this vector contains the specified element
     */
    default boolean contains(Object o) {
        return indexOf(o) != -1;
    }
}
