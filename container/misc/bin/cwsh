#!/usr/bin/python -tt

import sys, os, glob, re

def real_dirname(file):
    while os.path.islink(file):
        link = os.readlink(file)
        if link.startswith('/'):
            file = link
        else:
            file = os.path.join(os.path.dirname(file), link)
    return os.path.dirname(file)

BASEDIR = os.path.dirname(real_dirname(sys.argv[0]))

ENV_VAR_RE  = re.compile(r'^[A-Z][A-Z_0-9]*$')
ENV_LINE_RE = re.compile(r'^([A-Z][A-Z_0-9]*)\s*=\s*(.*)$')
COMMENT_RE  = re.compile(r'#.*$')

def load_env(dir):
    for entry in glob.glob(os.path.expanduser(os.path.join(dir, '*'))):
        if os.path.isdir(entry):
            load_env(os.path.join(dir, entry))
            continue

        var_name = os.path.basename(entry)
        if ENV_VAR_RE.match(var_name) == None:
            continue

        with open(entry, 'r') as f:
            contents = f.read().rstrip()
            # remove null's which are illegal in environment variables
            os.environ[var_name] = ''.join(contents.split('\0'))

def load_env_file(file):
    try:
        with open(os.path.expanduser(file), 'r') as f:
            for line in f:
                # remove comments and leading and trailing white spaces
                line = COMMENT_RE.sub("", line).strip()
                m = ENV_LINE_RE.match(line)
                if m != None:
                    os.environ[m.group(1)] = m.group(2)
    except:
        return

def load_env_all():
    load_env_file('~/app/repo/.cloudway/env')
    load_env('/etc/cloudway/env')
    load_env('~/.env')
    load_env('~/*/env')

    os.environ['CLOUDWAY_HOME'] = BASEDIR
    os.environ['PATH'] = ':'.join(collect_path_elements(os.environ, 'PATH'))
    os.environ['LD_LIBRARY_PATH'] = ':'.join(collect_path_elements(os.environ, 'LD_LIBRARY_PATH'))
    os.environ['CLOUDWAY_CLASSPATH'] = collect_classpath()

def collect_path_elements(env, var_name):
    app_env = dict(env)
    system_path = app_env[var_name] if var_name in app_env else False

    # Remove all LD_LIBRARY_PATH_ELEMENTs to avoid conflict with PATH
    if var_name == 'PATH':
        regex = re.compile(r'_LD_LIBRARY_PATH_ELEMENT$')
        for k in app_env.keys():
            if regex.search(k):
                app_env.pop(k)

    elements = []
    for name in app_env.keys():
        regex = re.compile(r'CLOUDWAY_.*_%s_ELEMENT' % var_name)
        if regex.search(name):
            elements.append(app_env[name])

    if system_path:
        elements.append(system_path)

    return elements

def collect_classpath():
    return ':'.join(glob.glob(os.path.join(BASEDIR, 'lib', '*.jar')))

if __name__ == '__main__':
    load_env_all()

    prog  = sys.argv[0]
    cmd   = ['/bin/bash']
    cmd_i = ['/bin/bash', '--init-file', '/etc/cloudway/bashrc', '-i']

    # Determine the command source
    #
    # There are two possible command sources:
    #
    # 1) authenticate with SSH public key, and key has command= section
    #    Get command and args from SSH_ORIGINAL_COMMAND
    # 2) Authenticate with other means
    #    Get command and args from sys.argv
    #
    orig_cmd = os.environ.get('SSH_ORIGINAL_COMMAND')
    if orig_cmd != None:
        # extract the command which was replaced by SSH auth key command
        cmd.append('-c')
        cmd.append(orig_cmd)
    else:
        # use the command passed by the user through SSH
        # be careful not to recurse (ssh adds $SHELL -c)
        allargs = sys.argv
        if allargs[:2] == [prog, '-c']:
            # the final command in a single string
            if allargs[2] == prog:
                # avoid recursion, drop to shell
                cmd = cmd_i
            else:
                cmd.append('-c')
                cmd.append(allargs[2:])
        else:
            if len(allargs) == 1:
                cmd = cmd_i
            else:
                cmd.append('-c')
                cmd.append(' '.join(allargs[1:]))

    os.execv(cmd[0], cmd)
    sys.exit(1)
